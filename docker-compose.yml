# 内部网络版本 - 不暴露数据库端口到主机（更安全）
#
# 启动说明：
# ────────────────────────────────────────────────────────────
# 1. 启动核心服务（PostgreSQL + Redis + Django + Nginx）:
#    docker-compose up -d
#
# 2. 启动核心服务 + RustFS 对象存储:
#    docker-compose --profile storage up -d
#
# 3. 启动全部服务（包含 RustFS + Flower 监控）:
#    docker-compose --profile storage --profile Flower up -d
#
# 4. 查看所有服务状态:
#    docker-compose ps -a
#
# 5. 停止并删除所有服务:
#    docker-compose down
#
#  RustFS 对象存储（可选服务 - 使用 --profile storage 启动）:
#    - 管理控制台: http://服务器IP:7901（直接访问，不通过 Nginx 代理）
#    - 文件访问: http://服务器IP/media/（通过 Nginx 代理，不暴露桶名称）
#    - API 端口（9000）: 仅内部网络访问，不对外暴露，确保安全性
#    - 默认账号密码: rustfsadmin / 查看 .env 文件中的 RUSTFS_ROOT_PASSWORD
#    - 注意: 启用对象存储需要在 .env 中设置 SNOW_USE_OBJECT_STORAGE=True
# ────────────────────────────────────────────────────────────

services:
  # PostgreSQL 数据库
  postgres:
    image: ${POSTGRES_IMAGE:-postgres:17-bookworm}
    container_name: ${CONTAINER_PREFIX:-secsnow}-postgres
    restart: always
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-secsnow}
      POSTGRES_USER: ${POSTGRES_USER:-secsnow}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secsnow123456}
      POSTGRES_INITDB_ARGS: --auth-host=md5
      PGDATA: /var/lib/postgresql/data/pgdata
      TZ: Asia/Shanghai
    volumes:
      - ${POSTGRES_DATA_DIR:-./db/postgres}:/var/lib/postgresql/data
    # 不暴露端口到主机，只在内部网络访问
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-secsnow}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # PgBouncer 连接池
  pgbouncer:
    image: ${PGBOUNCER_IMAGE:-edoburu/pgbouncer:latest}
    container_name: ${CONTAINER_PREFIX:-secsnow}-pgbouncer
    restart: always
    environment:
      DATABASE_URL: postgres://${POSTGRES_USER:-secsnow}:${POSTGRES_PASSWORD:-secsnow123456}@postgres:5432/${POSTGRES_DB:-secsnow}
      AUTH_TYPE: scram-sha-256
      POOL_MODE: transaction
      MAX_CLIENT_CONN: 1000
      DEFAULT_POOL_SIZE: 25
      MIN_POOL_SIZE: 5
      RESERVE_POOL_SIZE: 5
      SERVER_IDLE_TIMEOUT: 60
      SERVER_LIFETIME: 3600
      MAX_DB_CONNECTIONS: 50
      TZ: Asia/Shanghai
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD-SHELL", "PGPASSWORD=${POSTGRES_PASSWORD:-secsnow123456} psql -h 127.0.0.1 -p 5432 -U ${POSTGRES_USER:-secsnow} -d ${POSTGRES_DB:-secsnow} -c 'SELECT 1;' || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Redis 缓存和消息队列
  redis:
    image: ${REDIS_IMAGE:-redis:8.4.0}
    container_name: ${CONTAINER_PREFIX:-secsnow}-redis
    restart: always
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis123456} --appendonly yes
    environment:
      TZ: Asia/Shanghai
    volumes:
      - ${REDIS_DATA_DIR:-./redis/data}:/data
    # 不暴露端口到主机，只在内部网络访问
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # RustFS 对象存储（可选服务 - 需要启用时使用 --profile storage 启动）
  rustfs:
    profiles:
      - storage  # 需要使用 --profile storage 参数才会启动此服务
    image: ${RUSTFS_IMAGE:-rustfs/rustfs:latest}
    container_name: ${CONTAINER_PREFIX:-secsnow}-rustfs
    restart: always
    user: "0:0"  # 以 root 用户运行，避免权限问题
    security_opt:
      - "no-new-privileges:true"
    environment:
      # 数据卷路径
      RUSTFS_VOLUMES: /data/rustfs0
      # API 和控制台监听地址
      RUSTFS_ADDRESS: 0.0.0.0:9000
      RUSTFS_CONSOLE_ADDRESS: 0.0.0.0:9001
      RUSTFS_CONSOLE_ENABLE: "true"
      # CORS 设置
      RUSTFS_CORS_ALLOWED_ORIGINS: ${RUSTFS_CORS_ALLOWED_ORIGINS:-*}
      RUSTFS_CONSOLE_CORS_ALLOWED_ORIGINS: ${RUSTFS_CONSOLE_CORS_ALLOWED_ORIGINS:-*}
      # 访问密钥
      RUSTFS_ACCESS_KEY: ${RUSTFS_ROOT_USER:-rustfsadmin}
      RUSTFS_SECRET_KEY: ${RUSTFS_ROOT_PASSWORD:-rustfsadmin}
      # 禁用 KMS 加密服务（避免 KMS 未初始化错误）
      MINIO_KMS_KES_ENDPOINT: ""
      MINIO_KMS_AUTO_ENCRYPTION: "off"
      # 日志级别
      RUSTFS_OBS_LOGGER_LEVEL: info
      # 时区配置
      TZ: Asia/Shanghai
    volumes:
      - ${RUSTFS_DATA_DIR:-./rustfs/data}:/data
      - ${RUSTFS_LOG_DIR:-./rustfs/logs}:/app/logs
    # 端口映射：只暴露 RustFS Console 管理界面到主机
    # API 端口（9000）不暴露，所有文件访问通过 Nginx 代理
    ports:
      - "${RUSTFS_CONSOLE_PORT:-7901}:9001"  # 管理控制台端口 - 直接访问（http://服务器IP:7901）
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD", "sh", "-c", "curl -f http://localhost:9000/health && curl -f http://localhost:9001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # RustFS 初始化（自动创建 bucket）
  rustfs-init:
    profiles:
      - storage  # 需要使用 --profile storage 参数才会启动此服务
    image: ${MINIO_MC_IMAGE:-minio/mc:latest}  # 使用 minio client，因为 RustFS 兼容 S3 API
    container_name: ${CONTAINER_PREFIX:-secsnow}-rustfs-init
    depends_on:
      rustfs:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      echo '等待 RustFS 启动...';
      sleep 5;
      echo '配置 RustFS 别名...';
      mc alias set secsnow http://rustfs:9000 ${RUSTFS_ROOT_USER:-rustfsadmin} ${RUSTFS_ROOT_PASSWORD:-rustfsadmin};
      echo '创建 bucket: ${RUSTFS_BUCKET_NAME:-secsnow}';
      mc mb secsnow/${RUSTFS_BUCKET_NAME:-secsnow} --ignore-existing;
      echo '设置 bucket 为公开访问...';
      mc anonymous set public secsnow/${RUSTFS_BUCKET_NAME:-secsnow};
      echo 'RustFS 初始化完成！';
      "
    networks:
      - secsnow-network

  # Django Web 应用（前端）
  web:
    image: ${SECSNOW_IMAGE:-secsnow:secure}
    container_name: ${CONTAINER_PREFIX:-secsnow}-web
    restart: always
    environment:
      # Django 配置（使用 SNOW_ 前缀）
      SNOW_SECRET_KEY: ${SNOW_SECRET_KEY:-django-insecure-)+vh#@l4crslu5fza1e8da!2(0s10mw5%_1=*uko7cu9ju*yv-}
      SNOW_DEBUG: ${SNOW_DEBUG:-False}
      # 数据库配置（使用 SNOW_ 前缀）- 通过 PgBouncer 连接
      SNOW_POSTGRES_HOST: pgbouncer
      SNOW_POSTGRES_PORT: 5432
      SNOW_POSTGRES_NAME: ${POSTGRES_DB:-secsnow}
      SNOW_POSTGRES_USER: ${POSTGRES_USER:-secsnow}
      SNOW_POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secsnow123456}
      # Redis 配置（使用 SNOW_ 前缀）
      SNOW_REDIS_HOST: redis
      SNOW_REDIS_PORT: 6379
      SNOW_REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123456}
      #应用配置
      SECSNOW_VERSION: ${SECSNOW_VERSION:-v1.0.0}
      SNOW_ALLOWED_HOSTS: ${SNOW_ALLOWED_HOSTS:-*}
      SNOW_CSRF_TRUSTED_ORIGINS: ${SNOW_CSRF_TRUSTED_ORIGINS:-}
      SNOW_ACCOUNT_EMAIL_VERIFICATION: ${SNOW_ACCOUNT_EMAIL_VERIFICATION:-none}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY:-SecSnowEncryptKey2024567890AB}
      SNOW_PROTOCOL_HTTPS: ${SNOW_PROTOCOL_HTTPS:-http}
      SNOW_SIMPLEUI_HOME_TITLE: ${SNOW_SIMPLEUI_HOME_TITLE:-SECSNOW}
      SNOW_SIMPLEUI_LOGO: ${SNOW_SIMPLEUI_LOGO:-https://www.secsnow.cn/static/blog/img/logo.svg}
      #容器相关设置
      CONTAINER_EXPIRY_HOURS: ${CONTAINER_EXPIRY_HOURS:-2}
      MAX_CONTAINERS_PER_USER: ${MAX_CONTAINERS_PER_USER:-1}
      MAX_CONTAINERS_PER_CHALLENGE: ${MAX_CONTAINERS_PER_CHALLENGE:-100}
      MAX_CONTAINERS_PER_TEAM: ${MAX_CONTAINERS_PER_TEAM:-1}
      DOCKER_POOL_MIN_SIZE: ${DOCKER_POOL_MIN_SIZE:-5}
      DOCKER_POOL_MAX_SIZE: ${DOCKER_POOL_MAX_SIZE:-20}
      # 对象存储配置（使用 SNOW_ 前缀，支持 RustFS）
      SNOW_USE_OBJECT_STORAGE: ${SNOW_USE_OBJECT_STORAGE:-False}
      SNOW_STORAGE_ACCESS_KEY: ${SNOW_STORAGE_ACCESS_KEY:-rustfsadmin}
      SNOW_STORAGE_SECRET_KEY: ${SNOW_STORAGE_SECRET_KEY:-rustfsadmin}
      SNOW_STORAGE_BUCKET_NAME: ${SNOW_STORAGE_BUCKET_NAME:-secsnow}
      SNOW_STORAGE_ENDPOINT_URL: ${SNOW_STORAGE_ENDPOINT_URL:-http://rustfs:9000}
      SNOW_STORAGE_REGION: ${SNOW_STORAGE_REGION:-us-east-1}
      SNOW_STORAGE_LOCATION: ${SNOW_STORAGE_LOCATION:-}
      SNOW_STORAGE_USE_SSL: ${SNOW_STORAGE_USE_SSL:-False}
      SNOW_STORAGE_VERIFY_SSL: ${SNOW_STORAGE_VERIFY_SSL:-False}
      SNOW_STORAGE_PUBLIC_URL: ${SNOW_STORAGE_PUBLIC_URL:-}
      # 时区配置
      TZ: Asia/Shanghai
        
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ${WEB_MEDIA_DIR:-./web/media}:/opt/cloud/secsnow/media
      - ${WEB_LOG_DIR:-./web/log}:/opt/cloud/secsnow/log
      - ${WEB_STATIC_DIR:-./web/static}:/opt/cloud/secsnow/static
      - ${WEB_WHOOSH_DIR:-./web/whoosh_index}:/opt/cloud/secsnow/whoosh_index
      # 挂载宿主机信息（用于生成稳定的机器码）
      - /etc/machine-id:/host/etc/machine-id:ro
      - /sys/class/net:/host/sys/class/net:ro
    # 不暴露端口到主机，只通过 nginx 代理访问
    depends_on:
      postgres:
        condition: service_healthy
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD", "python", "-c", "import sys; sys.exit(0)"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Celery Worker（共享 web 镜像）
  celery-worker:
    image: ${SECSNOW_IMAGE:-secsnow:secure}
    container_name: ${CONTAINER_PREFIX:-secsnow}-celery-worker
    restart: always
    command: celery -A secsnow worker -l info --pool=gevent --concurrency=${CELERY_WORKER_CONCURRENCY:-20}
    environment:
      # Django 配置（使用 SNOW_ 前缀）
      SNOW_SECRET_KEY: ${SNOW_SECRET_KEY:-change-this-to-random-string}
      SNOW_DEBUG: ${SNOW_DEBUG:-False}
      # 数据库配置（使用 SNOW_ 前缀）- 通过 PgBouncer 连接
      SNOW_POSTGRES_HOST: pgbouncer
      SNOW_POSTGRES_PORT: 5432
      SNOW_POSTGRES_NAME: ${POSTGRES_DB:-secsnow}
      SNOW_POSTGRES_USER: ${POSTGRES_USER:-secsnow}
      SNOW_POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secsnow123456}
      # Redis 配置（使用 SNOW_ 前缀）
      SNOW_REDIS_HOST: redis
      SNOW_REDIS_PORT: 6379
      SNOW_REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123456}
      #容器相关设置
      CONTAINER_EXPIRY_HOURS: ${CONTAINER_EXPIRY_HOURS:-2}
      MAX_CONTAINERS_PER_USER: ${MAX_CONTAINERS_PER_USER:-1}
      MAX_CONTAINERS_PER_CHALLENGE: ${MAX_CONTAINERS_PER_CHALLENGE:-100}
      MAX_CONTAINERS_PER_TEAM: ${MAX_CONTAINERS_PER_TEAM:-1}
      DOCKER_POOL_MIN_SIZE: ${DOCKER_POOL_MIN_SIZE:-5}
      DOCKER_POOL_MAX_SIZE: ${DOCKER_POOL_MAX_SIZE:-20}
      # 对象存储配置（使用 SNOW_ 前缀，支持 RustFS）
      SNOW_USE_OBJECT_STORAGE: ${SNOW_USE_OBJECT_STORAGE:-False}
      SNOW_STORAGE_ACCESS_KEY: ${SNOW_STORAGE_ACCESS_KEY:-rustfsadmin}
      SNOW_STORAGE_SECRET_KEY: ${SNOW_STORAGE_SECRET_KEY:-rustfsadmin}
      SNOW_STORAGE_BUCKET_NAME: ${SNOW_STORAGE_BUCKET_NAME:-secsnow}
      SNOW_STORAGE_ENDPOINT_URL: ${SNOW_STORAGE_ENDPOINT_URL:-http://rustfs:9000}
      SNOW_STORAGE_REGION: ${SNOW_STORAGE_REGION:-us-east-1}
      SNOW_STORAGE_LOCATION: ${SNOW_STORAGE_LOCATION:-}
      SNOW_STORAGE_USE_SSL: ${SNOW_STORAGE_USE_SSL:-False}
      SNOW_STORAGE_VERIFY_SSL: ${SNOW_STORAGE_VERIFY_SSL:-False}
      SNOW_STORAGE_PUBLIC_URL: ${SNOW_STORAGE_PUBLIC_URL:-}
      # 时区配置
      TZ: Asia/Shanghai
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ${WEB_MEDIA_DIR:-./web/media}:/opt/cloud/secsnow/media
      - ${WEB_LOG_DIR:-./web/log}:/opt/cloud/secsnow/log
      # 挂载宿主机信息（用于生成稳定的机器码）
      - /etc/machine-id:/host/etc/machine-id:ro
      - /sys/class/net:/host/sys/class/net:ro
    depends_on:
      postgres:
        condition: service_healthy
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy
      web:
        condition: service_started
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD", "celery", "-A", "secsnow", "inspect", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Celery Beat（共享 web 镜像）
  celery-beat:
    image: ${SECSNOW_IMAGE:-secsnow:secure}
    container_name: ${CONTAINER_PREFIX:-secsnow}-celery-beat
    restart: always
    command: celery -A secsnow beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    environment:
      # Django 配置（使用 SNOW_ 前缀）
      SNOW_SECRET_KEY: ${SNOW_SECRET_KEY:-change-this-to-random-string}
      SNOW_DEBUG: ${SNOW_DEBUG:-False}
      # 数据库配置（使用 SNOW_ 前缀）- 通过 PgBouncer 连接
      SNOW_POSTGRES_HOST: pgbouncer
      SNOW_POSTGRES_PORT: 5432
      SNOW_POSTGRES_NAME: ${POSTGRES_DB:-secsnow}
      SNOW_POSTGRES_USER: ${POSTGRES_USER:-secsnow}
      SNOW_POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secsnow123456}
      # Redis 配置（使用 SNOW_ 前缀）
      SNOW_REDIS_HOST: redis
      SNOW_REDIS_PORT: 6379
      SNOW_REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123456}
      #容器相关设置
      CONTAINER_EXPIRY_HOURS: ${CONTAINER_EXPIRY_HOURS:-2}
      MAX_CONTAINERS_PER_USER: ${MAX_CONTAINERS_PER_USER:-1}
      MAX_CONTAINERS_PER_CHALLENGE: ${MAX_CONTAINERS_PER_CHALLENGE:-100}
      MAX_CONTAINERS_PER_TEAM: ${MAX_CONTAINERS_PER_TEAM:-1}
      DOCKER_POOL_MIN_SIZE: ${DOCKER_POOL_MIN_SIZE:-5}
      DOCKER_POOL_MAX_SIZE: ${DOCKER_POOL_MAX_SIZE:-20}
      # 对象存储配置（使用 SNOW_ 前缀，支持 RustFS）
      SNOW_USE_OBJECT_STORAGE: ${SNOW_USE_OBJECT_STORAGE:-True}
      SNOW_STORAGE_ACCESS_KEY: ${SNOW_STORAGE_ACCESS_KEY:-rustfsadmin}
      SNOW_STORAGE_SECRET_KEY: ${SNOW_STORAGE_SECRET_KEY:-rustfsadmin}
      SNOW_STORAGE_BUCKET_NAME: ${SNOW_STORAGE_BUCKET_NAME:-secsnow}
      SNOW_STORAGE_ENDPOINT_URL: ${SNOW_STORAGE_ENDPOINT_URL:-http://rustfs:9000}
      SNOW_STORAGE_REGION: ${SNOW_STORAGE_REGION:-us-east-1}
      SNOW_STORAGE_LOCATION: ${SNOW_STORAGE_LOCATION:-}
      SNOW_STORAGE_USE_SSL: ${SNOW_STORAGE_USE_SSL:-False}
      SNOW_STORAGE_VERIFY_SSL: ${SNOW_STORAGE_VERIFY_SSL:-False}
      SNOW_STORAGE_PUBLIC_URL: ${SNOW_STORAGE_PUBLIC_URL:-}
      # 时区配置
      TZ: Asia/Shanghai
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ${WEB_LOG_DIR:-./web/log}:/opt/cloud/secsnow/log
      # 挂载宿主机信息（用于生成稳定的机器码）
      - /etc/machine-id:/host/etc/machine-id:ro
      - /sys/class/net:/host/sys/class/net:ro
    depends_on:
      postgres:
        condition: service_healthy
      pgbouncer:
        condition: service_healthy
      redis:
        condition: service_healthy
      web:
        condition: service_started
    networks:
      - secsnow-network

  # Flower 监控（可选服务 - 使用 --profile Flower 启动）
  flower:
    profiles:
      - Flower  # 需要使用 --profile Flower 参数才会启动此服务
    image: ${SECSNOW_IMAGE:-secsnow:secure}
    container_name: ${CONTAINER_PREFIX:-secsnow}-flower
    restart: always
    # 添加基本认证保护（用户名:密码格式）
    command: >
      celery -A secsnow flower 
      --port=5555 
      --basic_auth=${FLOWER_USER:-admin}:${FLOWER_PASSWORD:-flower123456}
    environment:
      # Redis 配置（使用 SNOW_ 前缀）
      SNOW_REDIS_HOST: redis
      SNOW_REDIS_PORT: 6379
      SNOW_REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123456}
      # 时区配置
      TZ: Asia/Shanghai
    # 直接暴露 5555 端口到主机
    ports:
      - "${FLOWER_PORT:-5555}:5555"
    depends_on:
      - redis
      - celery-worker
    networks:
      - secsnow-network

  # Nginx 反向代理
  nginx:
    image: ${NGINX_IMAGE:-nginx:alpine}
    container_name: ${CONTAINER_PREFIX:-secsnow}-nginx
    restart: always
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ${NGINX_CONF_DIR:-./nginx/conf.d}:/etc/nginx/conf.d:ro
      - ${NGINX_SSL_DIR:-./nginx/ssl}:/etc/nginx/ssl:ro
      - ${WEB_MEDIA_DIR:-./web/media}:/usr/share/nginx/secsnow/media
      - ${WEB_STATIC_DIR:-./web/static}:/usr/share/nginx/secsnow/static
      - ${NGINX_LOG_DIR:-./web/log/nginx}:/var/log/nginx
    depends_on:
      - web
    networks:
      - secsnow-network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  secsnow-network:
    name: ${NETWORK_NAME:-secsnow-network}
    driver: bridge

volumes:
  postgres-data:
  redis-data:
